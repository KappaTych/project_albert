# Overivew ECS
____

+------------------+
|     Context      |
|------------------|
|    e       e     |      +-----------+
|        e     e---|----> |  Entity   |
|  e        e      |      |-----------|
|     e  e       e |      | Component |
| e            e   |      |           |      +-----------+
|    e     e       |      | Component-|----> | Component |
|  e    e     e    |      |           |      |-----------|
|    e      e    e |      | Component |      |   Data    |
+------------------+      +-----------+      +-----------+
  |
  |
  |     +-------------+  Groups:
  |     |      e      |  Subsets of entities in the context
  |     |   e     e   |  for blazing fast querying
  +---> |        +------------+
        |     e  |    |       |
        |  e     | e  |  e    |
        +--------|----+    e  |
                 |     e      |
                 |  e     e   |
                 +------------+

## Entity
____
An entity is a container holding data to represent certain objects in your application. You can add, replace or remove data from entities in form of IComponent. Entities have corresponding events to let you know if components were added, replaced or removed.

In this example you can see some generated methods for `PositionComponent`, `HealthComponent`, `MovableComponent`.
```C#
entity.AddPosition(3, 7);
entity.AddHealth(100);
entity.isMovable = true;

entity.ReplacePosition(10, 100);
entity.ReplaceHealth(entity.health.value - 1);
entity.isMovable = false;

entity.RemovePosition();

var hasPos = entity.hasPosition;
var movable = entity.isMovable;
```

## Context
____
The Context is the factory where you create and destroy entities. Use it to filter entities of interest.

```C#
// Contexts.game is kindly generated for you by the code generator
var gameContext = Contexts.game;
var entity = gameContext.CreateEntity();
entity.isMovable = true;

// Returns all entities having MovableComponent and PositionComponent.
// Matchers are also generated for you.
var entities = gameContext.GetEntities(Matcher<GameEntity>.AllOf(GameMatcher.Movable, GameMatcher.Position));
foreach (var e in entities) {
    // do something
}
```

## Group
____
Groups enable super quick filtering on entities in the context. They are continuously updated when entities change and can return groups of entities instantly.
```
var context = contexts.game;

var movables = context.GetGroup(GameMatcher.Movable);
var count = movables.count; // count is 0, the group is empty

var entity1 = context.CreateEntity();
entity1.isMovable = true;
var entity2 = context.CreateEntity();
entity2.IsMovable = true;

count = movables.count; // count is 2, the group contains the entity1 and entity2

// GetEntities() always provides an up to date list
var movableEntities = movables.GetEntities();
foreach (var e in movableEntities) {
  
}

entity1.Destroy();
entity2.Destroy();

count = movables.count; // count is 0, the group is empty
```
Both the group and fetched entities are cached, so even calling this method multiple times is super fast.Always prefer using groups when possible. `gameContext.GetEntities(GameMatcher.Movable)` internally uses groups, too.
Groups have events for `OnEntityAdded`, `OnEntityRemoved` and `OnEntityUpdated` to directly react to changes in the group.
```
gameContext.GetGroup(GameMatcher.Position).OnEntityAdded += (group, entity, index, component) => {
    // Do something
};
```

## Collector
____
The Collector provides an easy way to react to changes in a group over time.
```
var group = gameContext.GetGroup(GameMatcher.Position);
var collector = group.CreateCollector(GroupEvent.Added);

foreach (var e in collector.collectedEntities) {
    // do something with all the entities
    // that have been collected to this point of time
}
collector.ClearCollectedEntities();

collector.Deactivate();
```

## Matcher
____
Matchers are generated by the code generator and can be combined. Matchers are usually used to get groups of entities from the context of interest. Remember to prefix the matcher with the context name you are interested (e.g. GameMatcher, InputMatcher etc).

```
var matcher = GameMatcher.Movable;

GameMatcher.AllOf(GameMatcher.Movable, GameMatcher.Position);

GameMatcher.AnyOf(GameMatcher.Move, GameMatcher.Position);

GameMatcher
    .AllOf(GameMatcher.Position)
    .AnyOf(GameMatcher.Health, GameMatcher.Interactive)
    .NoneOf(GameMatcher.Animating);
```

## Systems
____
There are 5 different types of Systems:
- *IInitializeSystem:* Executes once (`system.Initialize()`)
- *IExecuteSystem:* Executes every frame (`system.Execute()`)
- *ICleanupSystem:* Executes every frame after the other systems are finished (`system.Cleanup()`)
- *ITearDownSystem:* Executes once, after the game ends (`system.TearDown()`)
- *ReactiveSystem:* Executes when the observed group changed (`system.Execute(Entity[])`)

I recommend you create systems for each single task or behaviour in your application and execute them in a defined order. This helps to keep your app deterministic.
```
var systems = new Systems()
    .Add(new SomeInitializeSystem(contexts))
    .Add(new SomeReactiveSystem(contexts))
    .Add(new SomeExecuteSystem(contexts));
```

### InitializeSystem
Initialize systems run once at the start of your program. They implement the interface `IInitializeSystem`, which defines the method `Initialize()`. This is where you set up your initial game state, in a similar way to Unity's `Start()` method.

Possible Use Case:
- Add event handlers to `Groups` or `Contexts`
- Create global entities that will exist for the lifetime of your game (e.g. for accessing configuration data)

```
public class CreateLevelSystem : IInitializeSystem {
    public void Initialize() {}
}
```

### ExecuteSystem
Execute systems run once per frame. They implement the interface `IExecuteSystem`, which defines the method `Execute()`. This is where you put code that needs to run every frame, similar to Unity's `Update()` method.

Possible Use Cases:
- Poll for events not represented as components.

```
public class MoveSystem : IExecuteSystem {
    public void Execute() {}
}
```

### CleanupSystem
Cleanup systems run at the end of each frame, after all other systems have completed their work. They implement the interface `ICleanupSystem`, which defines the method `Cleanup()`. These are useful if you want to create entities that only exist for one frame.

```
public class MyCleanupSystem : ICleanupSystem {
    public void Cleanup() {}
}
```

### TearDownSystem
Teardown systems run once at the end of your program. They implement the interface `ITearDownSystem`, which defines the method `TearDown()`. This is where you can clean up all resources acquired throughout the lifetime of your game.

Possible Use Cases:
- Release all resources not managed by Unity
- Flush modified files (e.g. save data, logs) to disk
- Gracefully terminate network connections

```
public class MyTearDownSystem : ITearDownSystem {
    public void TearDown() {}
}
```

### ReactiveSystem
Entitas also provides a special system called ReactiveSystem, which is using a Group Observer under the hood. 

Unlike the other systems, ReactiveSystems inherit from a base class `ReactiveSystem<TEntity>` instead of implementing an interface. 
Entitas generates an entity Type for each context in your game. If your contexts are `Game`, `GameState` and `Input`, Entitas generates three types: `GameEntity`, `GameStateEntity` and `InputEntity`. Reactive systems require that you provide the specific context and associated entity type to which they react.
The base class defines some abstract methods you must implement. First you must create a constructor that calls the base constructor and provides it with the appropriate context. You must override 3 methods: `GetTrigger()` returns a collector, this tells the system what events to react to. `Filter()` performs a final check on the entities returned by the collector, ensuring they have the required components attached before `Execute()`  is called on each of them. Execute() is where the bulk of your game logic resides.
Note: You should not try to combine a reactive system with an execute system - think of reactive systems as a special case of execute systems. All the other interfaces can be mixed.

```
using Entitas;
using UnityEngine;

[Game]
PositionComponent : IComponent {
    int x;
    int y;
}

[Game]
ViewComponent : IComponent {
    GameObject gameObject;
}

public class RenderPositionSystem: ReactiveSystem<GameEntity> {

    public RenderPositionSystem(Contexts contexts) : base(contexts.Game) {}

    protected override ICollector<GameEntity> GetTrigger(IContext<GameEntity> context) {
        // specify which component you are reacting to
        return context.CreateCollector(GameMatcher.Position);

        // you can also specify which type of event you need to react to
        return context.CreateCollector(GameMatcher.MyComponent.Added()); // the default
        return context.CreateCollector(GameMatcher.MyComponent.Removed());
        return context.CreateCollector(GameMatcher.MyComponent.AddedOrRemoved());

        // combine matchers with AnyOf and AllOf
        return context.CreateCollector(LevelMatcher.AnyOf(GameMatcher.Component1, GameMatcher.Component2));

        // use multiple matchers
        return context.CreateCollector(LevelMatcher.GameMatcher, GameMatcher.Component2.Removed());

        // or any combination of all the above
        return context.CreateCollector(LevelMatcher.AnyOf(GameMatcher.Component1, GameMatcher.Component2),
                                       LevelMatcher.Component3.Removed(),
                                       LevelMatcher.AllOf(GameMatcher.C4, GameMatcher.C5).Added());
    }

    }

    protected override bool Filter(GameEntity entity) {
        // check for required components (here it is position and view)
        return entity.hasView && entity.hasPosition;
    }

    protected override void Execute(List<GameEntity> entities) {
        foreach (var e in entities) {
            var pos = e.gridPosition.position;
            e.view.gameObject.transform.position = new Vector3(pos.x, pos.y, 0);
        }
    }
}
```

To react to changes of entities from multiple contexts you will need to use multi-reactive system. First you need to declare an interface that will combine entities from multiple contexts that have the same components, and you need to implement that interface for the entity classes via partial classes.
```
public interface PositionViewEntity : IEntity, IPosition, IView {}

public partial class EnemyEntity : PositionViewEntity {}
public partial class ProjectileEntity : PositionViewEntity {}
```
Then create a system inherited from MultiReactiveSystem and pass the new interface.
```
public class ViewSystem : MultiReactiveSystem<PositionViewEntity, Contexts> {

    public ViewSystem(Contexts contexts) : base(contexts) {}

    protected override ICollector[] GetTrigger(Contexts contexts) {
        return new ICollector[] {
            contexts.Enemy.CreateCollector(EnemyMatcher.Position),
            contexts.Projectile.CreateCollector(ProjectileMatcher.Position)
        };
    }

    protected override bool Filter(PositionViewEntityentity) {
        return entity.hasView && entity.hasPosition;
    }

    protected override void Execute(List<PositionViewEntity> entities) {
        foreach(var e in entities) {
            e.View.transform.position = e.Position.value;
        }
    }
}
```

### Features
Use them to group related systems together. This has the added benefit of separating the visual debugging objects for your systems in the Unity hierarchy. Now they can be inspected in logical groups instead of all at once.
Features also help you to enforce broader paradigmatic rules in your project. The order of execution of features is determined by the order in which they're added and is always respected by Entitas. Separating your systems into `InputSystems : Feature`,  `GameLogicSystems : Feature` and `RenderingSystems : Feature` then initializing them in that order provides an easy way of ensuring that game logic doesn't interfere with rendering.
Features require that you implement a constructor. Use the `Add()` method in the ctor to add systems to the feature. The order in which they are added here defines their execution order at runtime. Features can be used in your GameController to instantiate groups of systems together.
```
public class InputSystems : Feature
{
    public InputSystems(Contexts contexts) : base("Input Systems")
    {
        // order is respected 
        Add(new EmitInputSystem(contexts));
        Add(new ProcessInputSystem(contexts));
    }
}
```
Then in your GameController:
```
Systems createSystems(Contexts contexts) {

     // order is respected
     return new Feature("Systems")

         // Input executes first
         .Add(new InputSystems(contexts))
         // Update 
         .Add(new GameBoardSystems(contexts))
         .Add(new GameStateSystems(contexts))
         // Render executes after game logic 
         .Add(new ViewSystems(contexts))
         // Destroy executes last
         .Add(new DestroySystem(contexts));
}
```

Mixed interface:
```
public class UpdateBoardSystem : IInitializeSystem, ReactiveSystem<GameEntity> {

    Context _context;
    Group _myGroup;

    public UpdateBoardSystem (Contexts contexts) : base(context.game) {
        _context= contexts.game;
        _myGroup = _context.GetGroup(GameMatcher.Xyz);
    }

    public void Initialize() {}

    protected override Collector<GameEntity> GetTrigger(IContext<GameEntity> context) {}

    protected override bool Filter(GameEntity entity) {}

    protected override void Execute(List<GameEntity> entities) {
        foreach (var e in entities) {
            // do stuff
        }
    }
}
```

### Example Mixed System
This system is both an Execute and a Cleanup system. Its function is to monitor Unity's Input class for mouse clicks and create entities with InputComponent added. A separate system processes these components, then, in the Cleanup phase these entities are destroyed.
The advantage of this arrangement is that we could have multiple separate systems listening for `InputComponent` and doing different things with them. None of these systems should be responsible for destroying the entities they process, since we may later add more systems or remove existing ones. Still the entity should be destroyed before the next frame since we will never need it again.

```
using Entitas;
using UnityEngine;

public class EmitInputSystem : IExecuteSystem, ICleanupSystem {

    readonly InputContext _context;
    readonly IGroup<InputEntity> _inputs;

    // get a reference to the group of entities with InputComponent attached 
    public EmitInputSystem(Contexts contexts) {
        _context = contexts.input;
        _inputs = _context.GetGroup(InputMatcher.Input);
    }

    // this runs early every frame (defined by its order in GameController.cs)
    public void Execute() {

        // check for unity mouse click
        var input = Input.GetMouseButtonDown(0);        
         
        if(input) {
            // perform a raycast to see if we clicked an object
            var hit = Physics2D.Raycast(Camera.main.ScreenToWorldPoint(Input.mousePosition), Vector2.zero, 100);

            if(hit.collider != null) {

                // we hit an object, so this is a valid input.
                // create a new entity to represent the input
                // give it the position of the object we hit

                var pos = hit.collider.transform.position;
                _context.CreateEntity()
                     .AddInput((int)pos.x, (int)pos.y);
            }
        }
    }

    // ~~~~~~ OTHER SYSTEMS EXECUTE - PROCESS THE ENTITIES CREATED HERE ~~~~~ //

    // all other systems are done so we can destroy the input entities we created
    public void Cleanup() {
        // group.GetEntities() always provides an up-to-date list
        foreach(var e in _inputs.GetEntities()) {
            e.Destroy();
        }
    }
}
```